<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8">
  <title>DreamEcho - Oyente Walkie-Talkie</title>
  <style>
    body { margin:0; font-family:sans-serif; background:#f5f5f5; display:flex; flex-direction:column; align-items:center; }
    .container { max-width:800px; width:95%; background:white; padding:1em; margin:1em; border-radius:8px; box-shadow:0 2px 10px rgba(0,0,0,0.1); }
    h1 { text-align:center; }
    .videos { display:flex; justify-content:space-between; margin:1em 0; }
    video { width:48%; background:black; border-radius:4px; }
    #status, #oyentes { text-align:center; margin:0.5em 0; }
    .controls { text-align:center; margin:0.5em 0; }
    button, select, input { font-size:1em; padding:0.5em; margin:0.2em; }
    #chatLog { height:120px; overflow-y:auto; border:1px solid #ccc; padding:0.5em; background:#fafafa; }
    .chat-propio { color:blue; }
  </style>
</head>
<body>
  <div class="container">
    <h1>DreamEcho - Oyente</h1>
    <div class="videos">
      <video id="localVideo" autoplay muted playsinline></video>
      <video id="remoteVideo" autoplay playsinline controls></video>
    </div>
    <p id="status">Conectando...</p>
    <p id="oyentes">Oyentes: --</p>
    <div class="controls">
      <button id="talkBtn" disabled>Hablar (mantener)</button>
      <button onclick="modoMIDI()">ðŸŽ¹ Piano Digital</button>
      <button onclick="modoVirtual()">ðŸŽ§ Piano Virtual</button>
    </div>
    <div id="midiSelectContainer"></div>
    <div id="chatControles">
      <div id="chatLog"></div>
      <input id="chatInput" placeholder="Mensajeâ€¦" />
      <button id="sendChatBtn">Enviar</button>
    </div>
  </div>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.8.39/Tone.min.js"></script>
  <script>
    const statusEl = document.getElementById('status');
    const oyentesEl = document.getElementById('oyentes');
    const localVideo = document.getElementById('localVideo');
    const remoteVideo = document.getElementById('remoteVideo');
    const talkBtn = document.getElementById('talkBtn');
    const chatLog = document.getElementById('chatLog');
    const chatInput = document.getElementById('chatInput');
    const sendChatBtn = document.getElementById('sendChatBtn');
    const midiSelectContainer = document.getElementById('midiSelectContainer');

    let ws, pc, midiChannel;
    let audioTrack;
    let canTalk = false, midiActive = false;
    let output = null, synth = null, pedal = false;
    const notasActivas = new Set(), notasSostenidas = new Set();
    const username = prompt('Â¿CÃ³mo quieres que te vean en el chat?', 'Oyente') || 'Oyente';

    ws = new WebSocket('wss://dreamecho.onrender.com');
    pc = new RTCPeerConnection({ iceServers:[{ urls:'stun:stun.l.google.com:19302' }] });

    ws.onopen = () => { statusEl.textContent = 'Conectado'; initMedia(); };
    ws.onmessage = async ({ data }) => {
      const msg = JSON.parse(data);
      switch (msg.type) {
        case 'stats':
          oyentesEl.textContent = `Oyentes: ${msg.clients}`;
          break;
        case 'chat':
          appendChat(msg.user, msg.text);
          break;
        case 'talk':
          handlePeerTalk(msg.talking);
          break;
        case 'midiActive':
          handlePeerMidiActive();
          break;
        case 'signal':
          if (msg.offer) {
            // Add local tracks before answer
            await initMediaTracks();
            await pc.setRemoteDescription(msg.offer);
            const answer = await pc.createAnswer();
            await pc.setLocalDescription(answer);
            ws.send(JSON.stringify({ type:'signal', answer: pc.localDescription }));
          } else if (msg.answer) {
            await pc.setRemoteDescription(msg.answer);
          } else if (msg.candidate) {
            await pc.addIceCandidate(msg.candidate);
          }
          break;
      }
    };
    ws.onerror = () => statusEl.textContent = 'Error WS';
    ws.onclose = () => statusEl.textContent = 'WS cerrado';

    pc.onicecandidate = ({ candidate }) => { if (candidate) ws.send(JSON.stringify({ type:'signal', candidate })); };
    pc.ontrack = ev => { remoteVideo.srcObject = ev.streams[0]; };
    pc.ondatachannel = ev => {
      if (ev.channel.label === 'midi') {
        midiChannel = ev.channel;
        midiChannel.onmessage = e => handleMidiMessage(JSON.parse(e.data));
      }
    };

    async function initMedia(){
      // Only initialize local media and send talk button enabled
      const stream = await navigator.mediaDevices.getUserMedia({ video:true, audio:true });
      localVideo.srcObject = stream;
      audioTrack = stream.getAudioTracks()[0];
      talkBtn.disabled = false;
      // Setup MIDI channel for sending events
      midiChannel = pc.createDataChannel('midi'); setupMidiChannel(midiChannel);
    }
    async function initMediaTracks(){
      // Add tracks to peer connection
      const stream = localVideo.srcObject;
      stream.getTracks().forEach(t => pc.addTrack(t, stream));
    }

    // Push-to-talk
    talkBtn.onmousedown = () => {
      if (!midiActive) {
        canTalk = true;
        audioTrack.enabled = true;
        ws.send(JSON.stringify({ type:'talk', user: username, talking: true }));
        talkBtn.textContent = 'Hablando...';
      }
    };
    talkBtn.onmouseup = () => {
      if (canTalk) {
        canTalk = false;
        audioTrack.enabled = false;
        ws.send(JSON.stringify({ type:'talk', user: username, talking: false }));
        talkBtn.textContent = 'Hablar (mantener)';
      }
    };

    function handlePeerTalk(talking) {
      if (talking) audioTrack.enabled = false;
      else if (!canTalk && !midiActive) audioTrack.enabled = true;
    }

    function handlePeerMidiActive() {
      midiActive = true;
      talkBtn.disabled = true;
      setTimeout(() => { midiActive = false; talkBtn.disabled = false; }, 300);
    }

    // Chat
    function appendChat(user, text) {
      const div = document.createElement('div');
      div.innerHTML = `<small>[${new Date().toLocaleTimeString()}]</small> <strong>${user}:</strong> ${text}`;
      if (user === username) div.classList.add('chat-propio');
      chatLog.appendChild(div);
      chatLog.scrollTop = chatLog.scrollHeight;
    }
    sendChatBtn.onclick = () => {
      const t = chatInput.value.trim();
      if (t && ws.readyState === WebSocket.OPEN) {
        ws.send(JSON.stringify({ type:'chat', user: username, text: t }));
        chatInput.value = '';
      }
    };
    chatInput.onkeydown = e => { if (e.key === 'Enter') sendChatBtn.click(); };

    function setupMidiChannel(ch) { ch.onopen = () => {}; }

    // MIDI physical mode
    function modoMIDI() {
      navigator.requestMIDIAccess().then(ma => {
        midiSelectContainer.innerHTML = '';
        const sel = document.createElement('select'); sel.innerHTML = '<option>--Salida MIDI--</option>';
        Array.from(ma.outputs.values()).forEach(o => sel.innerHTML += `<option value="${o.id}">${o.name}</option>`);
        sel.onchange = () => { output = ma.outputs.get(sel.value); };
        sel.value = Array.from(ma.outputs.keys())[0]; sel.dispatchEvent(new Event('change'));
        midiSelectContainer.appendChild(sel);
        Array.from(ma.inputs.values()).forEach(inp => {
          inp.onmidimessage = evt => {
            if (midiChannel.readyState === 'open') midiChannel.send(JSON.stringify({ data: Array.from(evt.data), time: performance.now() }));
            ws.send(JSON.stringify({ type: 'midiActive' }));
          };
        });
      });
    }

    // Virtual piano mode with full samples
    async function modoVirtual() {
      statusEl.textContent = 'Cargando piano virtual...';
      pedal = false; notasActivas.clear(); notasSostenidas.clear();
      await Tone.start();
      synth = new Tone.Sampler({
        urls: {
          A0:  'A0.mp3', C1:  'C1.mp3', 'D#1':'Ds1.mp3', 'F#1':'Fs1.mp3',
          A1:  'A1.mp3', C2:  'C2.mp3', 'D#2':'Ds2.mp3', 'F#2':'Fs2.mp3',
          A2:  'A2.mp3', C3:  'C3.mp3', 'D#3':'Ds3.mp3', 'F#3':'Fs3.mp3',
          A3:  'A3.mp3', C4:  'C4.mp3', 'D#4':'Ds4.mp3', 'F#4':'Fs4.mp3',
          A4:  'A4.mp3', C5:  'C5.mp3', 'D#5':'Ds5.mp3', 'F#5':'Fs5.mp3',
          A5:  'A5.mp3', C6:  'C6.mp3', 'D#6':'Ds6.mp3', 'F#6':'Fs6.mp3',
          A7:  'A7.mp3', C8:  'C8.mp3'
        },
        baseUrl:'https://tonejs.github.io/audio/salamander/',
        release:0.4,
        onload:()=>{ statusEl.textContent='Piano virtual listo.'; }
      }).toDestination();
    }

    // Handle incoming MIDI
    function handleMidiMessage(msg) {
      const [st,note,vel] = msg.data; const cmd = st & 0xf0;
      if (output) output.send(new Uint8Array(msg.data));
      if (synth) {
        const time = Tone.now(); const freq = Tone.Frequency(note,'midi').toFrequency();
        if (cmd===0x90 && vel>0) { synth.triggerAttack(freq,time,Math.pow(vel/127,2)); notasActivas.add(freq); notasSostenidas.delete(freq); }
        else if (cmd===0x80 || (cmd===0x90&&vel===0)) { if(pedal){ notasActivas.delete(freq); notasSostenidas.add(freq);} else{ synth.triggerRelease(freq,time); notasActivas.delete(freq); notasSostenidas.delete(freq);} }
        else if (st===176&&note===64) { pedal=vel>=64; if(!pedal) notasSostenidas.forEach(f=>{ if(!notasActivas.has(f)){ synth.triggerRelease(f,Tone.now()); notasSostenidas.delete(f);} }); }
      }
      ws.send(JSON.stringify({ type:'midiActive' }));
    }
  </script>
</body>
</html>
