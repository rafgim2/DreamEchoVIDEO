<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8">
  <title>DreamEcho - Oyente</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.8.39/Tone.min.js"></script>
  <style>
    body {
      font-family: sans-serif;
      padding: 1em;
      text-align: center;
      background-color: #c1f7f2;
      margin: 0;
      min-height: 100vh;
      overflow-x: hidden;
      overflow-y: auto;
    }
    .marco {
      width: 90%;
      max-width: 700px;
      margin: 1em auto;
      padding: 1em;
      background: white;
      border: 5px solid blue;
      border-radius: 1em;
      box-sizing: border-box;
    }
    h1 { font-size: 2.5em; margin: 0.2em 0; }
    #recuentoOyentes, #status { font-size: 1.1em; color: #555; margin: 0.5em 0; }
    button { margin: 0.5em; font-size: 1em; padding: 0.8em 1.5em; cursor: pointer; }

    .video-container {
      display: flex;
      gap: 1em;
      justify-content: center;
      flex-wrap: wrap;
      margin: 1em 0;
    }
    .video-block {
      flex: 1 1 45%;
      display: flex;
      flex-direction: column;
      align-items: center;
    }
    .video-block video {
      width: 100%;
      max-height: 250px;
      background: black;
      border-radius: 0.5em;
    }
    .video-label {
      margin-top: 0.3em;
      font-weight: bold;
      color: #333;
    }
    #talkBtn {
      padding: 0.8em 2em;
      font-size: 1.1em;
      margin: 1em 0;
      border: none;
      border-radius: 0.7em;
      background: #2196f3;
      color: white;
      cursor: pointer;
    }
    #talkBtn:active {
      transform: scale(0.96);
    }

    #midiSelectContainer select {
      margin-top: 1em;
      padding: 0.5em;
      font-size: 1em;
    }

    #chatLog {
      width: 100%;
      height: 180px;
      margin: 1em 0 0.5em;
      padding: 0.5em;
      border: 1px solid #ccc;
      overflow-y: auto;
      text-align: left;
      background: #fafafa;
      border-radius: 0.5em;
    }

    #chatInput { width: 70%; padding: 0.5em; font-size: 1em; }
    #sendChatBtn { padding: 0.6em 1em; font-size: 1em; margin-left: 0.5em; cursor: pointer; }
    .chat-mensaje-propio { color: blue; }

    .ripple {
      position: fixed;
      border-radius: 50%;
      transform: scale(0);
      pointer-events: none;
      animation: rippleAnim 0.8s ease-out forwards;
    }

    @keyframes rippleAnim {
      to { transform: scale(15); opacity: 0; }
    }
    #modoBtns button{margin:0.3em 0.7em;}
  </style>
</head>
<body>
  <div class="marco">
    <h1>DreamEcho - Oyente</h1>
    <p><a href="https://www.youtube.com/@rafgim" target="_blank" rel="noopener">¬© By Rafael Gimeno</a></p>

    <div class="video-container">
      <div class="video-block">
        <video id="localVideo" autoplay muted playsinline></video>
        <p class="video-label">T√∫</p>
      </div>
      <div class="video-block">
        <video id="remoteVideo" autoplay playsinline></video>
        <p class="video-label">Artista</p>
      </div>
    </div>

    <button id="talkBtn">üì¢ Mant√©n pulsado para hablar</button>

    <div id="modoBtns">
      <button onclick="modoMIDI()">üéπ Usar mi piano digital</button>
      <button onclick="modoVirtual()">üéß Escuchar con sonido virtual</button>
    </div>
    <div id="midiSelectContainer"></div>

    <p id="recuentoOyentes">Oyentes conectados: --</p>
    <p id="status">Esperando conexi√≥n‚Ä¶</p>

    <div id="chatControles">
      <div id="chatLog"></div>
      <input id="chatInput" placeholder="Escribe tu mensaje‚Ä¶" />
      <button id="sendChatBtn">üó®Ô∏è Enviar</button>
    </div>
  </div>

  <script>
    const statusEl = document.getElementById('status');
    const oyentesEl = document.getElementById('recuentoOyentes');
    const localVideo = document.getElementById('localVideo');
    const remoteVideo = document.getElementById('remoteVideo');
    const talkBtn = document.getElementById('talkBtn');
    const chatLog = document.getElementById('chatLog');
    const chatInput = document.getElementById('chatInput');
    const sendChatBtn = document.getElementById('sendChatBtn');
    const midiSelectContainer = document.getElementById('midiSelectContainer');

    // --- MIDI bidireccional ---
    let midiChannelOut = null;    // DataChannel "midi-oyente": env√≠a desde el oyente
    let midiChannelIn  = null;    // DataChannel "midi-artista": recibe desde el artista
    let midiAccess = null;
    let midiOutput = null;
    let sampler = null;
    let pedal = false;
    const notasActivas = new Set();
    const notasSostenidas = new Set();
    let modo = "ninguno"; // "midi" o "virtual"

    // --- MIDI OUTPUT/INPUT LOGIC ---
    function modoMIDI() {
      modo = "midi";
      midiSelectContainer.innerHTML = "Buscando dispositivos MIDI‚Ä¶";
      navigator.requestMIDIAccess().then(ma => {
        midiAccess = ma;
        const outputs = Array.from(ma.outputs.values());
        if (!outputs.length) {
          midiSelectContainer.innerHTML = 'No hay dispositivos MIDI.';
          midiOutput = null;
          return;
        }
        midiSelectContainer.innerHTML = '';
        const sel = document.createElement('select');
        sel.innerHTML = '<option value="">-- Elige salida MIDI --</option>';
        outputs.forEach(o => sel.innerHTML += `<option value="${o.id}">${o.name}</option>`);
        sel.onchange = () => {
          midiOutput = ma.outputs.get(sel.value);
          statusEl.textContent = `Salida MIDI: ${midiOutput ? midiOutput.name : "ninguna"}`;
        };
        sel.value = outputs[0].id;
        sel.dispatchEvent(new Event('change'));
        midiSelectContainer.appendChild(sel);
      }).catch(() => {
        midiSelectContainer.innerHTML = 'No se pudo acceder a MIDI.';
      });
    }
    async function modoVirtual() {
      modo = "virtual";
      midiOutput = null;
      midiSelectContainer.innerHTML = '';
      pedal = false; notasActivas.clear(); notasSostenidas.clear();
      await Tone.start();
      sampler = new Tone.Sampler({
        urls: {
          A0: 'A0.mp3', C1: 'C1.mp3', 'D#1': 'Ds1.mp3', 'F#1': 'Fs1.mp3',
          A1: 'A1.mp3', C2: 'C2.mp3', 'D#2': 'Ds2.mp3', 'F#2': 'Fs2.mp3',
          A2: 'A2.mp3', C3: 'C3.mp3', 'D#3': 'Ds3.mp3', 'F#3': 'Fs3.mp3',
          A3: 'A3.mp3', C4: 'C4.mp3', 'D#4': 'Ds4.mp3', 'F#4': 'Fs4.mp3',
          A4: 'A4.mp3', C5: 'C5.mp3', 'D#5': 'Ds5.mp3', 'F#5': 'Fs5.mp3',
          A5: 'A5.mp3', C6: 'C6.mp3', 'D#6': 'Ds6.mp3', 'F#6': 'Fs6.mp3',
          A7: 'A7.mp3', C8: 'C8.mp3'
        },
        baseUrl: 'https://tonejs.github.io/audio/salamander/',
        release: 0.4,
        onload: () => { statusEl.textContent = 'Modo virtual listo.'; }
      }).toDestination();
      statusEl.textContent = 'Cargando piano virtual‚Ä¶';
    }

    // --- MIDI OUT: reproduce msg MIDI recibido (virtual o f√≠sico) ---
    function playMidiMessage(msg) {
      const [st, note, vel] = msg.data;
      const cmd = st & 0xf0;
      if (modo === "midi" && midiOutput) {
        midiOutput.send(new Uint8Array(msg.data));
      }
      if (modo === "virtual" && sampler) {
        const freq = Tone.Frequency(note, 'midi').toFrequency();
        if (cmd === 0x90 && vel > 0) {
          const velNorm = vel / 127;
          const velScaled = Math.pow(velNorm, 2);
          sampler.triggerAttack(freq, Tone.now(), velScaled);
          notasActivas.add(freq);
          notasSostenidas.delete(freq);
        } else if (cmd === 0x80 || (cmd === 0x90 && vel === 0)) {
          if (pedal) {
            notasActivas.delete(freq);
            notasSostenidas.add(freq);
          } else {
            sampler.triggerRelease(freq, Tone.now());
            notasActivas.delete(freq);
            notasSostenidas.delete(freq);
          }
        } else if (st === 176 && note === 64) {
          pedal = vel >= 64;
          if (!pedal) {
            notasSostenidas.forEach(f => {
              if (!notasActivas.has(f)) {
                sampler.triggerRelease(f, Tone.now());
                notasSostenidas.delete(f);
              }
            });
          }
        }
      }
    }

    // --- MIDI IN: env√≠a MIDI tocado localmente al artista ---
    function sendMidiMessage(data) {
      if (midiChannelOut && midiChannelOut.readyState === "open") {
        midiChannelOut.send(JSON.stringify({ data: Array.from(data) }));
      }
    }

    // --- MIDI DETECTION Y ENV√çO ---
    function listenMidiInput() {
      if (!midiAccess) return;
      const inputs = Array.from(midiAccess.inputs.values());
      if (!inputs.length) return;
      inputs.forEach(input => {
        input.onmidimessage = ({ data }) => {
          sendMidiMessage(data);
          playMidiMessage({ data });
        };
      });
      statusEl.textContent = `Escuchando entrada MIDI: ${inputs.map(i=>i.name).join(", ")}`;
    }

    // --- WALKIE-TALKIE ---
    let localStream = null;
    let realAudioTrack = null;
    let silentAudioTrack = null;
    let audioSender = null;
    let pressingTalk = false;
    let remoteSpeaking = false;

    function createSilentAudioTrack() {
      const ctx = new (window.AudioContext || window.webkitAudioContext)();
      const oscillator = ctx.createOscillator();
      oscillator.frequency.value = 0;
      const dst = ctx.createMediaStreamDestination();
      oscillator.connect(dst);
      oscillator.start();
      setTimeout(()=>oscillator.stop(), 100);
      return dst.stream.getAudioTracks()[0];
    }

    async function initLocalVideo() {
      try {
        localStream = await navigator.mediaDevices.getUserMedia({ video: true, audio: true });
        realAudioTrack = localStream.getAudioTracks()[0];
        silentAudioTrack = createSilentAudioTrack();
        localVideo.srcObject = localStream;
        localStream.getTracks().forEach(t => {
          let sender = pc.addTrack(t, localStream);
          if (t.kind === 'audio') audioSender = sender;
        });
        // Empieza muteado (pista silenciosa)
        if(audioSender && audioSender.track !== silentAudioTrack) {
          audioSender.replaceTrack(silentAudioTrack);
        }
      } catch (err) {
        console.error('No se pudo acceder a la c√°mara o micro:', err);
        statusEl.textContent = '‚ö†Ô∏è No se pudo acceder a c√°mara/micro.';
      }
    }

    initLocalVideo();

    function updateMicState() {
      if (!audioSender) return;
      const activar = pressingTalk && !remoteSpeaking;
      if (activar) {
        if (audioSender.track !== realAudioTrack)
          audioSender.replaceTrack(realAudioTrack);
      } else {
        if (audioSender.track !== silentAudioTrack)
          audioSender.replaceTrack(silentAudioTrack);
      }
    }

    function pressTalk() {
      pressingTalk = true;
      ws.send(JSON.stringify({ type: 'talk', speaking: true }));
      updateMicState();
    }
    function releaseTalk() {
      pressingTalk = false;
      ws.send(JSON.stringify({ type: 'talk', speaking: false }));
      updateMicState();
    }
    ['mousedown','touchstart'].forEach(e => talkBtn.addEventListener(e, pressTalk));
    ['mouseup','mouseleave','touchend','touchcancel'].forEach(e => talkBtn.addEventListener(e, releaseTalk));

    // --- WEBRTC ---
    const ws = new WebSocket('wss://dreamecho.onrender.com');
    const pc = new RTCPeerConnection({ iceServers: [{ urls: 'stun:stun.l.google.com:19302' }] });

    pc.onicecandidate = ({ candidate }) => {
      if (candidate) ws.send(JSON.stringify({ type: 'signal', candidate }));
    };

    pc.ontrack = ev => {
      remoteVideo.srcObject = ev.streams[0];
    };

    // DataChannels MIDI
    pc.ondatachannel = ev => {
      if (ev.channel.label === "midi-artista") {
        midiChannelIn = ev.channel;
        midiChannelIn.onmessage = ({data}) => {
          try {
            const msg = JSON.parse(data);
            if (msg.data) playMidiMessage(msg);
          } catch (e) { /* ignorar */ }
        };
      }
    };

    ws.onopen = () => {
      statusEl.textContent = 'Conectado, esperando oferta...';
    };

    ws.onmessage = async ({ data }) => {
      const msg = JSON.parse(typeof data === 'string' ? data : await data.text());
      switch (msg.type) {
        case 'stats':
          oyentesEl.textContent = `Oyentes conectados: ${msg.clients}`;
          break;
        case 'chat':
          appendChat(msg.user, msg.text);
          break;
        case 'talk':
          remoteSpeaking = msg.speaking;
          updateMicState();
          break;
        case 'signal':
          if (msg.offer) {
            await initLocalVideo();
            // --- MIDI DataChannel "midi-oyente" para enviar (abierto por el oyente) ---
            midiChannelOut = pc.createDataChannel("midi-oyente");
            midiChannelOut.onopen = () => {
              statusEl.textContent += " | Canal MIDI listo";
              listenMidiInput();
            };
            await pc.setRemoteDescription(new RTCSessionDescription(msg.offer));
            const answer = await pc.createAnswer();
            await pc.setLocalDescription(answer);
            ws.send(JSON.stringify({ type: 'signal', answer: pc.localDescription }));
          } else if (msg.answer) {
            await pc.setRemoteDescription(new RTCSessionDescription(msg.answer));
          } else if (msg.candidate) {
            await pc.addIceCandidate(new RTCIceCandidate(msg.candidate));
          }
          break;
      }
    };

    ws.onerror = () => { statusEl.textContent = 'Error en la conexi√≥n.'; };
    ws.onclose = () => { statusEl.textContent = 'Conexi√≥n cerrada.'; };

    const username = prompt('¬øC√≥mo quieres que te vean en el chat?', 'Oyente') || 'Oyente';
    function appendChat(user, text) {
      const msgEl = document.createElement('div');
      msgEl.innerHTML = `<small>[${new Date().toLocaleTimeString()}]</small> <strong>${user}:</strong> ${text}`;
      if (user === username) msgEl.classList.add('chat-mensaje-propio');
      chatLog.appendChild(msgEl);
      chatLog.scrollTop = chatLog.scrollHeight;
    }
    function sendChat() {
      const t = chatInput.value.trim();
      if (t && ws.readyState === WebSocket.OPEN) {
        ws.send(JSON.stringify({ type: 'chat', user: username, text: t }));
        chatInput.value = '';
      }
    }
    sendChatBtn.addEventListener('click', sendChat);
    chatInput.addEventListener('keydown', e => { if (e.key === 'Enter') sendChat(); });
  </script>
</body>
</html>
